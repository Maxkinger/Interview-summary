## 数据结构(一)——深入理解并查集

### 一、动态连通性

何为动态连通性？考虑以下整数对象构成的图：



<img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86.assets/image-20210729000408506.png" alt="image-20210729000408506" style="zoom:50%;" />

针对上面的图，很明显有

* 1 和 2 连通，2 和 3 连通
* 7 和 8 连通

除此之外，由于 1 连通 2，2 连通 3，我们认为 1 与 3 也是连通的。也就是说，只要从一个节点出发，有路径可以到达另外一个节点，就说这两个节点联通。

然而，由于 1 不能达到 7 或者 8，所以我们说 1 与 7 不连通，同理 1 与 8 也不连通。

但是假如我们把 3 和 7 用一条边连起来，如下：

<img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86.assets/image-20210729001029359.png" alt="image-20210729001029359" style="zoom:50%;" />



此时 1 和 7，1 和 8 就都连通了。实际上现在任意两个节点都是连通的。

所以，针对这些节点的连通性问题，我们希望能够有一种数据结构，实现如下的要求：

* 输入两个节点，输出它们是否连通
* 输入两个节点，如果不相连，可以将它们连通

也即满足如下接口的实现：

```java
public interface DisjointSets {
  void connect(int p, int q);// 连接 p、q
  boolean isConnected(int p, int q);// 查询 p、q 是否连接
}
```

### 二、实现

如何实现上述这样一个数据结构呢？

我们直觉上会立马想到，可以构造一个节点类 `Node`，类里面有一个列表 `ArrayList<Node>`，记录了与该节点连接的其他节点。但是，这样的数据结构会导致，当我们要查询两个节点是否相连通的时候，我们会进行很多迭代和递归的操作。其次如果每个节点都用这种结构，意味着我们会重复地记录很多边。在节点很多的时候性能会很受限。这并不是一个好的想法，我们需要更进一步。

#### 优化——从连接关系下手

刚才我们知道，将所有节点和他们之间的连接都记录下来，并不是一个好的办法。那我们可以换一个角度思考这个问题，其实我们并不关心这些节点到底是怎么连接的，我们只关心这几个节点是否互相连通。也就是说，我们不需要知道 1 具体和哪几个节点相连，我们只要知道，1、2、3 是一个组，组里的每个节点都互相连通。

从上面的想法出发，假设初始时有 0、1、2、3、4、5、6 这些节点，并且互不相连。初始化如下：

```java
// {} 代表集合
{0},{1},{2},{3},{4},{5},{6}
```

当我们进行 `connect(int p, int q)` 和 `isConnected(int p, int q)` 的操作时，这些集合变化如下：



