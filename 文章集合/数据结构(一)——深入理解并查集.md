## 数据结构(一)——深入理解并查集

### 一、动态连通性

何为动态连通性？考虑以下整数对象构成的图：



<img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86.assets/image-20210729000408506.png" alt="image-20210729000408506" style="zoom:50%;" />

针对上面的图，很明显有

* 1 和 2 连通，2 和 3 连通
* 7 和 8 连通

除此之外，由于 1 连通 2，2 连通 3，我们认为 1 与 3 也是连通的。也就是说，只要从一个节点出发，有路径可以到达另外一个节点，就说这两个节点联通。

然而，由于 1 不能达到 7 或者 8，所以我们说 1 与 7 不连通，同理 1 与 8 也不连通。

但是假如我们把 3 和 7 用一条边连起来，如下：

<img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86.assets/image-20210729001029359.png" alt="image-20210729001029359" style="zoom:50%;" />



此时 1 和 7，1 和 8 就都连通了。实际上现在任意两个节点都是连通的。

所以，针对这些节点的连通性问题，我们希望能够有一种数据结构，实现如下的要求：

* 输入两个节点，输出它们是否连通
* 输入两个节点，如果不相连，可以将它们连通

也即满足如下接口定义的实现：

```java
public interface DisjointSets {
  void connect(int p, int q);// 连接 p、q
  boolean isConnected(int p, int q);// 查询 p、q 是否连接
}
```

### 二、实现

如何实现上述这样一个数据结构呢？

我们直觉上会立马想到，可以构造一个节点类 `Node`，类内部有一个列表 `List<Node>`，记录了与该节点连接的其他节点。但是，这样的数据结构会导致，当我们要查询两个节点是否相连通的时候，我们会进行很多迭代和递归的操作。其次如果每个节点都用这种结构，意味着我们会重复地记录很多边。在节点很多的时候性能会很受限。这并不是一个好的想法，我们需要更进一步。

#### 优化 1——从连接关系下手（ListOfSets）

刚才我们知道，将所有节点和他们之间的连接都记录下来，并不是一个好的办法。那我们可以换一个角度思考这个问题，其实我们并不关心这些节点到底是怎么连接的，我们只关心这几个节点是否互相连通。也就是说，我们不需要知道 1 具体和哪几个节点相连，我们只要知道，1、2、3 是一个组，组里的每个节点都互相连通。

从上面的想法出发，假设初始时有 0、1、2、3、4、5、6 这些节点，并且互不相连。初始化如下：

```java
// {} 代表集合
{0},{1},{2},{3},{4},{5},{6}
```

当我们进行 `connect(int p, int q)` 和 `isConnected(int p, int q)` 的操作时，比如下面这些操作：

```java
connect(0, 1); // {0,1} {2} {3} {4} {5} {6}
connect(1, 2); // {0, 1, 2} {3} {4} {5} {6}
connect(0, 4); // {0, 1, 2, 4} {3} {5} {6}
connect(3, 5); // {0, 1, 2, 4} {3, 5} {6}
isConnected(2, 4); // true
isConnected(3, 0); // false
connect(4, 2); // {0, 1, 2, 4} {3, 5} {6}
connect(4, 6); // {0, 1, 2, 4, 6} {3, 5} 
connect(3, 6); // {0, 1, 2, 3, 4, 5, 6} 
isConnected(3, 0)// true
```

是不是感觉一目了然并且元素之间的关系很清晰了？而且对于 n 个元素来说，我们最多只需要使用 n 个 set 就可以达成目标了。

这个做法的关键点就在于，我们并不去考虑每个元素之间到底是**如何连接**的，而是只关心**哪些元素相互之间连接**在一起了。

##### 缺点

上面的做法看上去似乎很美好，但是细想一下，就会发现有问题了。假如我们使用 java 来实现上面的做法，那我们可能会使用 `List<Set<Integer>>` 这样的一个数据结构。

当我们尝试调用 `isConnected(int p, int q)` 的时候，我们需要至少遍历一遍 List 去找到 p 在哪个 Set 然后再判断 q 在不在里面。

同样，当我们要调用 `connect(int p, int q)` 去连接两个元素的时候，我们也至少需要遍历一遍 List。并且我们还要处理 Set 的合并和删除。这意味着时间复杂度都是 O(N)：

| isConnected(int p, int q) | connect(int p, int q) |
| ------------------------- | --------------------- |
| O(N)                      | O(N)                  |

我们还有更好的做法。

#### 优化 2——使用数组而非集合（QuickFind）

在优化1中，之所以最后得到的时间复杂度是 O(N)，是因为我们必须遍历整个 List 才能确定某一元素的位置。如果我们只要知道元素的值就能立刻知道元素的位置的话，那我们就不需要遍历了，时间复杂度不就立马降下来了吗？

知道一个元素的值，怎么样才能立刻知道元素的位置呢？你可能马上会想到使用 `Map` 这样的数据结构。但是对于整数元素而言，我们有更简单的实现方式——数组。将元素的值作为数组的下标，而下标对应的数组值代表一个 Set，如下：

<img src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86.assets/image-20210731182835226.png" alt="image-20210731182835226" style="zoom:50%;" />

我们用上面的数组来表示前面我们提到的 `List<Set<Integer>>` 的数据结构。下标 0，1，2，4 对应的值都是 4，所以他们是同一个 Set。其余下标同理。当然，数组内的值可以是任意的，只要下标是同一个 Set 的值相同，非同一个 Set 的值不同即可。

现在，让我们再来重新考虑事件复杂度的问题：

*  `isConnected(int p, int q)`

  实现如下：

  ```java
  public boolean isConnected(int p, int q) {
    return arr[p] == arr[q]; // 判断 p、q 下标对应的值是否相同
  }
  ```

  Wow！只需要一行代码就可以了，不再需要遍历，事件复杂度直接变为 O(1)！

* `connect(int p, int q)`

  实现如下：

  ```java
  public void connect(int p, int q) {
    int pSet = arr[p];
    int qSet = arr[q];
    for (int i = 0; i < arr.length; i++) {
      // 如果当前下标对应的值等于 p 所对应的值，那么改成 q 对应的值，相当于把 pSet 和 qSet 合并
      if (arr[i] = pSet) {
        arr[i] = qSet;
      }
    }
  }
  ```

  代码很简单，逻辑不难理解。并且我们不需要去对 `List<Set<Integer>>` 这样的数据结构进行各种往复遍历操作了。非常精炼高效的代码。唯一的缺点是事件复杂度仍然是 O(N)。

到现在，我们进一步优化了实现，使用一个数组就代替了 `List<Set<Integer>>` 这样的复杂结构。优化 2 的时间复杂度如下：

| isConnected(int p, int q) | connect(int p, int q) |
| ------------------------- | --------------------- |
| O(1)                      | O(N)                  |

比起优化 1，我们成功地把 `isConnectd` 的时间复杂度缩小到了 O(1)。这对于大量的数据来说，是很大的性能提升。

**Tips：**当然，你可能会问，如果元素不是整数，而是一个 `object` 怎么办？简单，把数组换成 `HashMap` 即可。实际上就是把 `object` 映射成 `HashMap` 的 `Entry` 数组下标。

#### 优化 3 ——

